============== UNDO Used by Transactions===========
select s.sid
      ,s.serial#
      ,s.username
      ,s.machine
      ,s.status
      ,s.lockwait
      ,t.used_ublk
      ,t.used_urec
      ,t.start_time
from v$transaction t
inner join v$session s on t.addr = s.taddr;
====================================
SELECT * FROM V$TRANSACTION WHERE STATUS='ACTIVE';
==============================
set echo on pagesize 100 linesize 132

select
case when bitand(flag,power(2,7)) > 0 then 'Rolling Back'
                                          else 'Not Rolling Back'
       end   as "Roll Status"
from v$transaction
where addr in (select taddr from v$session where username = upper('&&1'));

select s.sid, s.serial#, s.client_info, t.addr, sum(t.used_ublk)
from v$transaction t, v$session s
where t.addr = s.taddr
group by s.sid, s.serial#, s.client_info, t.addr;



The first query returns the rollback status of the transaction; the second returns the used UNDO blocks being generated by the transaction or read to undo the work that has already been done. The client_info column may or may not be populated (it isn't in these examples) but it is provided to help differentiate different sessions an application user may have running so that the transaction or transactions of interest can be monitored. Looking at an example should help; a long-running transaction is in progress in session #1; looking at the UNDO blocks being allocated (from a second session) we see the USED_UBLK column increasing in value and that the transaction is not rolling back:

===========================
XID  in ash
match it what that
v$active_session_history

http://nagaappani.blogspot.in/2013/04/oracle-streams-synchronous-capture.html

http://sateeshv-dbainfo.blogspot.in/2016/09/streams-troubleshooting-guide.html
Streams Capture Process Status is DISABLED, Yet it is Still Running and Capturing Changes (Doc ID 351325.1)

http://worldoforacle-dba.blogspot.in/2012/08/identify-long-running-transaction-in.html

execute DBMS_APPLY_ADM.STOP_APPLY(apply_name => 'ACTEVENT_APPLY');
Oracle Support Master Note for Streams Setup Scripts (Doc ID 789445.1
https://hiteshgondalia.wordpress.com/category/oracle-stream/
https://docs.oracle.com/cd/B19306_01/server.102/b14229/strms_qpmon.htm#i1007127
How to exclude operations in a Streams environment (Doc ID 814602.1)
How to Exclude Specific DML Operations from the Capture Process When Using Streams (Doc ID 239571.1)
https://docs.oracle.com/cd/B13789_01/server.101/b10727/strms_mo.htm#1006450  ---> Capture Troubleshooting
https://docs.oracle.com/cd/B28359_01/server.111/b28321/strms_qpmon.htm#STRMS163
https://ksadba.wordpress.com/2009/01/23/oracle-streams-set_tag-and-capture-rules-skip-ddl-dml/
https://eversmily.wordpress.com/2011/09/15/troubleshooting-streams-capture-when-status-is-paused-for-flow-control-id-746247-1/

Troubleshooting Oracle Streams Performance Issues (Doc ID 730036.1)

How to Use LogMiner to Determine Problem SQL in a Streams Environment (Doc ID 311620.1)

Troubleshooting Long-Running Transactions in Oracle Streams (Doc ID 783927.1)
https://getmehere.wordpress.com/2009/05/17/streams/
Note:273674.1 Streams Configuration Report and Health Check Script
Note:302018.1 Example Streams Apply DML Handler Showing LCR Column Rename
Note:239623.1 How To Exclude A Table From Schema Capture And Replication 
                When Using Schema Level Streams Replication
Note:238457.1 What DML and DDL is Captured by Streams
Note:238455.1 Streams Supported and Unsupported Datatypes
Note:801135.1 How to use Rule Conditions to discard unsupported LCRs in
                Streams Clients between different releases

NOTE:1457500.1 - CREATING A NEGATIVE RULE SET TO FILTER OUT UNWANTED SPECIFIC UPDATE DML OPERATION IN A UNIDIRCTIONAL STREAMS REPLICATION ENVIRONMENT
How to exclude operations in a Streams environment (Doc ID 814602.1)	



http://m.blog.itpub.net/17252115/viewspace-1302870/

While clearing the ignored transactions I faced the following error on the apply side.. 

SQL> execute dbms_apply_adm.set_parameter('ACTEVENT_APPLY','_ignore_transaction','389.26.691378');
BEGIN dbms_apply_adm.set_parameter('ACTEVENT_APPLY','_ignore_transaction','389.26.691378'); END;

*
ERROR at line 1:
ORA-26742: Maximum number of ignored transactions exceeded
ORA-06512: at "SYS.DBMS_LOGREP_UTIL", line 67
ORA-06512: at "SYS.DBMS_APPLY_ADM", line 74
ORA-06512: at line 1


The reason why this error comes up is that there were transactions those were previously ignored and it is still present. So maximum number of ignored transactions was witnessed.

To clear them I executed the below command: 

exec dbms_apply_adm.set_parameter('ACTEVENT_APPLY','_ignore_transaction',null);

After this I was able to ignore the rest of the transactions 


SELECT distinct ' '|| a.streams_name ||'  '||a.streams_type||' ' || a.CUMULATIVE_MESSAGE_COUNT ||' '|| b.xid ||' '|| c.session_id ||'' 
||c.session_serial# ||' '|| 
d.username ||' '|| c.program ||'  '|| c.sql_id ||'' || c.event ||'' from v$streams_transaction a,v$logmnr_transaction b, v$active_session_history c,
dba_users d where a.XIDUSN=b.XIDUSN and a.XIDSLT=b.XIDSLT and a.XIDSQN=b.XIDSQN and b.xid=c.xid and c.user_id=d.USER_id and b.mining_status = 'ACTIVE'; 


select t.start_time, s.sid,s.serial#,s.username,s.status,s.schemaname,
s.osuser,s.process,s.machine,s.terminal,s.program,s.module,s.type, to_char(s.logon_time,'DD/MON/YY HH24:MI:SS') logon_time
from v$transaction t, v$session s
where s.saddr = t.ses_addr and s. status = 'ACTIVE'
order by start_time


In 10.2 and above, the GV$STREAMS_TRANSACTION dynamic performance view can be used to assess any long running transactions when asynchronous capture is used. An example query would be:
col XID for a30
select streams_name "Streams Name", 
streams_type "Streams Type", 
xidusn||'.'||xidslt||'.'||xidsqn XID, 
to_number (sysdate-last_message_time)*1440 
"Time Since Last Message (min)" 
from GV$STREAMS_TRANSACTION 
where to_number (sysdate-last_message_time)*1440 >= 20 
order by "Time Since Last Message (min)";

 select xid, xidusn, xidslt, xidsqn, mining_status from v$logmnr_transaction where mining_status ='ACTIVE';

 select session_id, xid, xidusn, xidslt, xidsqn, state, type, mining_status, count(1)
from v$logmnr_transaction where mining_status = 'ACTIVE' and xid='&xid'
group by session_id, xid, xidusn, xidslt, xidsqn, state, type, mining_status;
 
The DBA_APPLY_SPILL_TXN view can also provide information concerning long running transactions. Information can be found here that shows the first SCN for the spilled transaction, the creation time of the first message for the spilled transaction, how many messages have been received and acknowledged for the transaction, etc. This information can be correlated with that in GV$STREAMS_TRANSACTION to determine if a transaction is long running, if it has spilled or not, and how long the transaction has been open.
select Apply_name "Apply Name", 
xidusn||'.'||xidslt||'.'||xidsqn XID, 
first_scn "First SCN", 
first_message_create_time "First Message Time", 
message_count "Message Count", 
spill_creation_time "Spill Time" 
from DBA_APPLY_SPILL_TXN 
order by "Spill Time";

3.3 Streams Healthcheck
The Streams healthcheck script is a comprehensive collection of information about a Streams environment from a particular database. Information about the script and links to download it for a particular version can be found in the following note: 

Note.273674.1 Streams Configuration Report and Health Check Script 

The output of this script can be used to diagnose long-running transactions. In particular, the output for all versions features a section called:
++ Current Long Running Transactions ++
This will list the session identifier (SID) running the transaction, the local transaction ID (XID) for the transaction, the amount of time the transaction has been open, the program running the transaction, and the terminal it is being run from. This output is for all transactions in the database, not just Streams transactions. However, this information can be correlated by XID with the following Streams healthcheck sections to determine if these are Streams transactions or not:
++ OPEN STREAMS CAPTURE TRANSACTIONS ++ 
++ OPEN STREAMS APPLY TRANSACTIONS ++
Also, a long-running transaction is likely to have apply spilled some of its messages, so the following healthcheck section can be viewed for information concerning the apply spill:
++ APPLY SPILLED TRANSACTIONS ++
In addition, the ++ APPLY Reader Statistics ++ section contains information concerning what is the oldest XID browsed by the apply reader. This may correlate to a long-running transaction.


====== to list the sql_id and username causing long running txn============
select distinct a.streams_name,a.streams_type,a.CUMULATIVE_MESSAGE_COUNT,b.xid,c.session_id,c.session_serial#,d.username,c.sql_id,c.event
from v$streams_transaction a,v$logmnr_transaction b,v$active_session_history c,dba_users d
where a.XIDUSN=b.XIDUSN
and a.XIDSLT=b.XIDSLT
and a.XIDSQN=b.XIDSQN
and b.xid=c.xid
and c.user_id=d.USER_id
and  b.mining_status = 'ACTIVE'
and a.CUMULATIVE_MESSAGE_COUNT > 5;

				
SELECT r.RULE_SET_NAME, r.RULE_SET_TYPE "SET TYPE", s.RULE_NAME, s.RULE_CONDITION 
FROM DBA_STREAMS_SCHEMA_RULES s, DBA_STREAMS_RULES r 
WHERE s.rule_name = r.rule_name 
AND s.streams_name = 'PAYMENTEVENT_CAPTURE' 
AND s.streams_type = 'CAPTURE';


SELECT r.rule_name, r.rule_owner 
FROM dba_rule_set_rules rs, dba_capture c, dba_rules r 
WHERE c.rule_set_name=rs.rule_set_name and 
c.rule_set_owner=rs.rule_set_owner and 
rs.rule_name=r.rule_name and 
rs.rule_owner=r.rule_owner


Master Note for Troubleshooting Streams Capture 'WAITING For REDO' or INITIALIZING (Doc ID 313279.1)

dba_apply_error

SQL> SELECT queue_table FROM DBA_QUEUE_TABLES WHERE owner = 'EMCDU';

QUEUE_TABLE
------------------------------
AQHANDLERQUEUE
INT$ACTEVENT_T
INT$PAYMEVENT_T
PAYMQUEUE
SCHEDULERQUEUE

SQL> select object_name,object_type,owner from dba_objects where object_name='AQREPLQUEUE';

OBJECT_NAME                                                                                                                      OBJECT_TYPE         OWNER
-------------------------------------------------------------------------------------------------------------------------------- ------------------- ------------------------------
AQREPLQUEUE                                                                                                                      TABLE               EMCDU
SQL> select owner,NAME,QUEUE_TABLE,QUEUE_TYPE,NETWORK_NAME,USER_COMMENT from dba_queues where owner='EMCDU';

OWNER                          NAME                           QUEUE_TABLE                    QUEUE_TYPE           NETWORK_NAME         USER_COMMENT
------------------------------ ------------------------------ ------------------------------ -------------------- -------------------- --------------------------------------------------
EMCDU                          AQ$_ACTQUEUE_E                 ACTQUEUE                       EXCEPTION_QUEUE                           exception queue
EMCDU                          AQ$_AQHANDLERQUEUE_E           AQHANDLERQUEUE                 EXCEPTION_QUEUE                           exception queue
EMCDU                          AQ$_INT$PAYMEVENT_T_E          INT$PAYMEVENT_T                EXCEPTION_QUEUE                           exception queue
EMCDU                          AQ$_PAYMQUEUE_E                PAYMQUEUE                      EXCEPTION_QUEUE                           exception queue
EMCDU                          INT$PAYMEVENT_Q                INT$PAYMEVENT_T                NORMAL_QUEUE                              Payment Event Queue
EMCDU                          AQ$_AQPMRPQUEUE_E              AQPMRPQUEUE                    EXCEPTION_QUEUE                           exception queue
EMCDU                          AQ_PMRPMESSAGE_Q               AQPMRPQUEUE                    NORMAL_QUEUE                              Activation Advanced Queue for new AQ Handler frame
EMCDU                          AQ$_SCHEDULERQUEUE_E           SCHEDULERQUEUE                 EXCEPTION_QUEUE                           exception queue
EMCDU                          SCHD_MESSAGE_Q                 SCHEDULERQUEUE                 NORMAL_QUEUE                              Activation Oracle AQ for new SCHEDULER Framework
EMCDU                          AQ_REPMESSAGE_Q                AQREPLQUEUE                    NORMAL_QUEUE                              Activation Advanced Queue for new AQ Handler frame
EMCDU                          AQ$_AQREPLQUEUE_E              AQREPLQUEUE                    EXCEPTION_QUEUE                           exception queue

OWNER                          NAME                           QUEUE_TABLE                    QUEUE_TYPE           NETWORK_NAME         USER_COMMENT
------------------------------ ------------------------------ ------------------------------ -------------------- -------------------- --------------------------------------------------
EMCDU                          AQ_ACTMESSAGE_Q                AQHANDLERQUEUE                 NORMAL_QUEUE                              Activation Advanced Queue for new AQ Handler frame
EMCDU                          PMNTMESSAGE_Q                  PAYMQUEUE                      NORMAL_QUEUE                              Payment Message Queue
EMCDU                          AQ$_INT$ACTEVENT_T_E           INT$ACTEVENT_T                 EXCEPTION_QUEUE                           exception queue
EMCDU                          INT$ACTEVENT_Q                 INT$ACTEVENT_T                 NORMAL_QUEUE                              Activation Event Queue
EMCDU                          ACTMESSAGE_Q                   ACTQUEUE                       NORMAL_QUEUE                              Activation Message Queue


col LWM_MESSAGE_NUMBER format 99999999999999999
col HWM_MESSAGE_NUMBER format 99999999999999999
col apply_name for a20
select sid,
serial#,
state,
apply#,
apply_name,
TOTAL_ASSIGNED,
TOTAL_RECEIVED,
LWM_MESSAGE_NUMBER,
to_char(LWM_MESSAGE_CREATE_TIME,'DD/MM/YY HH24:MI'),
HWM_MESSAGE_NUMBER,
to_char(HWM_MESSAGE_CREATE_TIME,'DD/MM/YY HH24:MI'),
total_applied,
total_errors,
TOTAL_ASSIGNED-total_applied "Remaining"
from v$streams_apply_coordinator;

Queue tables will only be dropped, if all the queues in the table are stopped..

https://twiki.cern.ch/twiki/bin/view/PSSGroup/StreamsOperationsManual

Capture latency:
COLUMN CAPTURE_NAME HEADING 'Capture|Process|Name' FORMAT A30
COLUMN LATENCY_SECONDS HEADING 'Latency|in|Seconds' FORMAT 99999999999999
COLUMN CREATE_TIME HEADING 'Event Creation|Time' FORMAT A20
COLUMN ENQUEUE_TIME HEADING 'Enqueue Time' FORMAT A20
COLUMN ENQUEUE_MESSAGE_NUMBER HEADING 'Message|Number' FORMAT 99999999999999

SELECT CAPTURE_NAME,
       (ENQUEUE_TIME-ENQUEUE_MESSAGE_CREATE_TIME)*86400 LATENCY_SECONDS, 
       TO_CHAR(ENQUEUE_MESSAGE_CREATE_TIME, 'HH24:MI:SS MM/DD/YY') CREATE_TIME,
       TO_CHAR(ENQUEUE_TIME, 'HH24:MI:SS MM/DD/YY') ENQUEUE_TIME,
       ENQUEUE_MESSAGE_NUMBER
  FROM V$STREAMS_CAPTURE;

Apply Latency:

COLUMN APPLY_NAME HEADING 'Apply Process|Name' FORMAT A17
COLUMN 'Latency in Seconds' FORMAT 999999
COLUMN 'Message Creation' FORMAT A17
COLUMN 'Apply Time' FORMAT A17
COLUMN APPLIED_MESSAGE_NUMBER HEADING 'Applied|Message|Number' FORMAT 99999999999999
SELECT APPLY_NAME,
(APPLY_TIME-APPLIED_MESSAGE_CREATE_TIME)*86400 "Latency in Seconds",
TO_CHAR(APPLIED_MESSAGE_CREATE_TIME,'HH24:MI:SS MM/DD/YY')
"Message Creation",
TO_CHAR(APPLY_TIME,'HH24:MI:SS MM/DD/YY') "Apply Time",
APPLIED_MESSAGE_NUMBER
FROM DBA_APPLY_PROGRESS;
  ===========================
COLUMN SERVER_ID HEADING 'Apply Server ID' FORMAT 99999999
COLUMN STATE HEADING 'Apply Server State' FORMAT A20
COLUMN APPLIED_MESSAGE_NUMBER HEADING 'Applied Message|Number' FORMAT 99999999999999
COLUMN MESSAGE_SEQUENCE HEADING 'Message Sequence|Number' FORMAT 99999999999999

SELECT SERVER_ID, STATE, APPLIED_MESSAGE_NUMBER, MESSAGE_SEQUENCE,XIDUSN,XIDSLT,XIDSQN,DEP_XIDUSN,DEP_XIDSLT,DEP_XIDSQN
  FROM V$STREAMS_APPLY_SERVER
  WHERE APPLY_NAME = 'ACTEVENT_APPLY'
  ORDER BY SERVER_ID;
================================
COLUMN OPERATION HEADING 'Operation' FORMAT A20
COLUMN OPTIONS HEADING 'Options' FORMAT A20
COLUMN OBJECT_OWNER HEADING 'Object|Owner' FORMAT A10
COLUMN OBJECT_NAME HEADING 'Object|Name' FORMAT A10
COLUMN COST HEADING 'Cost' FORMAT 99999999

SELECT p.OPERATION, p.OPTIONS, p.OBJECT_OWNER, p.OBJECT_NAME, p.COST
  FROM V$SQL_PLAN p, V$SESSION s, V$STREAMS_APPLY_SERVER a
  WHERE a.APPLY_NAME = 'ACTEVENT_APPLY' AND a.SERVER_ID = 2
    AND s.SID = a.SID
    AND p.HASH_VALUE = s.SQL_HASH_VALUE;
================================
Variation of above two scripts:
COLUMN SERVER_ID HEADING 'Apply Server ID' FORMAT 99999999
COLUMN STATE HEADING 'Apply Server State' FORMAT A20
COLUMN APPLIED_MESSAGE_NUMBER HEADING 'Applied Message|Number' FORMAT 99999999999999
COLUMN MESSAGE_SEQUENCE HEADING 'Message Sequence|Number' FORMAT 99999999999999

SELECT SERVER_ID, STATE, APPLIED_MESSAGE_NUMBER, MESSAGE_SEQUENCE 
  FROM V$STREAMS_APPLY_SERVER
  ORDER BY SERVER_ID;

COLUMN OPERATION HEADING 'Operation' FORMAT A20
COLUMN OPTIONS HEADING 'Options' FORMAT A20
COLUMN OBJECT_OWNER HEADING 'Object|Owner' FORMAT A10
COLUMN OBJECT_NAME HEADING 'Object|Name' FORMAT A10
COLUMN COST HEADING 'Cost' FORMAT 99999999

SELECT p.OPERATION, p.OPTIONS, p.OBJECT_OWNER, p.OBJECT_NAME, p.COST
  FROM V$SQL_PLAN p, V$SESSION s, V$STREAMS_APPLY_SERVER a
      where s.SID = a.SID AND p.HASH_VALUE = s.SQL_HASH_VALUE;
================================
Spilled transactions in apply process:
COLUMN APPLY_NAME HEADING 'Apply Name' FORMAT A20
COLUMN 'Transaction ID' HEADING 'Transaction ID' FORMAT A15
COLUMN FIRST_SCN HEADING 'First SCN'   FORMAT 99999999
COLUMN MESSAGE_COUNT HEADING 'Message Count' FORMAT 99999999
 
SELECT APPLY_NAME,
       XIDUSN ||'.'|| 
       XIDSLT ||'.'||
       XIDSQN "Transaction ID",
       FIRST_SCN,
       MESSAGE_COUNT,SPILL_CREATION_TIME,FIRST_MESSAGE_CREATE_TIME
  FROM DBA_APPLY_SPILL_TXN;
===============================



COLUMN queue_schema FORMAT A12
COLUMN queue_name FORMAT A20
SELECT queue_schema, queue_name,
unbrowsed_msgs, overspilled_msgs, memory_usage, publisher_state
FROM
V$BUFFERED_PUBLISHERS;
NOTE: The Flow Control query will
show:

* the queue owner and name
* the number of messages that have
been enqueued, but not browsed
* the number of messages that have been
spilled, but not browsed
* the percentage of the streams pool that is being
used (or 0 if there is no streams pool)
* the state of the publisher.
Possible values are:

– PUBLISHING MESSAGES (normal)
– IN FLOW CONTROL:
TOO MANY UNBROWSED MESSAGES
– IN FLOW CONTROL: OVERSPILLED MESSAGES
– IN
FLOW CONTROL: INSUFFICIENT MEMORY AND UNBROWSED MESSAGES

This last column
will really help to determine why flow control is being enabled for a system and
what can
be done to resolve the matter.  
================================
Relog Scanning Latency:
COLUMN CAPTURE_NAME HEADING 'Capture|Process|Name' FORMAT A10
COLUMN LATENCY_SECONDS HEADING 'Latency|in|Seconds' FORMAT 999999
COLUMN LAST_STATUS HEADING 'Seconds Since|Last Status' FORMAT 999999
COLUMN CAPTURE_TIME HEADING 'Current|Process|Time'
COLUMN CREATE_TIME HEADING 'Event|Creation Time' FORMAT 999999

SELECT CAPTURE_NAME,
       ((SYSDATE - CAPTURE_MESSAGE_CREATE_TIME)*86400) LATENCY_SECONDS,
       ((SYSDATE - CAPTURE_TIME)*86400) LAST_STATUS,
       TO_CHAR(CAPTURE_TIME, 'HH24:MI:SS MM/DD/YY') CAPTURE_TIME,       
       TO_CHAR(CAPTURE_MESSAGE_CREATE_TIME, 'HH24:MI:SS MM/DD/YY') CREATE_TIME
  FROM V$STREAMS_CAPTURE;
==================================
Long running transactions:
set lines 2500
column start_time format a20
column sid format 99999
column serial# format 999999
column username format a10
column status format a10
column schemaname format a10
column osuser format a10
column process format a10
column machine format a15
column terminal format a10
column program format a25
column module format a10
column logon format a20

prompt ####################################################
prompt # current transactions:
prompt ####################################################
select t.start_time,s.sid,s.serial#,s.username,s.status,s.schemaname,s.sql_id,
s.osuser,s.process,s.machine,s.terminal,s.program,s.module,to_char(s.logon_time,'DD/MON/YY HH24:MI:SS') logon_time
from v$transaction t, v$session s
where s.saddr = t.ses_addr
order by start_time;
===============================
execute dbms_capture_adm.stop_capture('CAPTURE_NAME'); 
execute dbms_capture_adm.set_parameter('CAPTURE_NAME','_ignore_transaction','TXN_ID'); 
execute dbms_capture_adm.start_capture('CAPTURE_NAME'); 


prompt ++ Current Long Running Transactions ++ 
prompt Current transactions open for more than 20 minutes 

col runlength HEAD 'Txn Open|Minutes' format 9999.99 
col sid HEAD 'Session' format a13 
col xid HEAD 'Transaction|ID' format a18 
col terminal HEAD 'Terminal' format a10 
col program HEAD 'Program' format a27 wrap 

select t.inst_id, sid||','||serial# sid,xidusn||'.'||xidslot||'.'||xidsqn xid, (sysdate - start_date )* 1440
runlength ,terminal,program from gv$transaction t, gv$session s where t.addr=s.taddr 
and (sysdate - start_date) * 1440 > 20; 


select streams_name "Streams Name", 
streams_type "Streams Type", 
xidusn||'.'||xidslt||'.'||xidsqn XID, 
to_number (sysdate-last_message_time)*1440 
"Time Since Last Message (min)" 
from GV$STREAMS_TRANSACTION 
where to_number (sysdate-last_message_time)*1440 >= 20 
order by "Time Since Last Message (min)" desc;
=============================
See what apply process is doing:

COLUMN APPLY_NAME HEADING 'Apply Process Name' FORMAT A22
COLUMN PROCESS_NAME HEADING 'Process Name' FORMAT A12
COLUMN STATE HEADING 'State' FORMAT A17
COLUMN TOTAL_ASSIGNED HEADING 'Total|Transactions|Assigned' FORMAT 99999999
COLUMN TOTAL_MESSAGES_APPLIED HEADING 'Total|Messages|Applied' FORMAT 99999999

SELECT r.APPLY_NAME,
       SUBSTR(s.PROGRAM,INSTR(S.PROGRAM,'(')+1,4) PROCESS_NAME,
       r.STATE,
       r.TOTAL_ASSIGNED, 
       r.TOTAL_MESSAGES_APPLIED
  FROM V$STREAMS_APPLY_SERVER R, V$SESSION S 
  WHERE r.SID = s.SID AND 
        r.SERIAL# = s.SERIAL# 
  ORDER BY r.APPLY_NAME, r.SERVER_ID;
=============================
See what capture is doing:

COLUMN CAPTURE_NAME HEADING 'Capture|Name' FORMAT A7
COLUMN PROCESS_NAME HEADING 'Capture|Process|Number' FORMAT A7
COLUMN SID HEADING 'Session|ID' FORMAT 9999
COLUMN SERIAL# HEADING 'Session|Serial|Number' FORMAT 999999
COLUMN STATE HEADING 'State' FORMAT A27
COLUMN TOTAL_MESSAGES_CAPTURED HEADING 'Redo|Entries|Evaluated|In Detail' FORMAT 999999999
COLUMN TOTAL_MESSAGES_ENQUEUED HEADING 'Total|LCRs|Enqueued' FORMAT 999999999

SELECT c.CAPTURE_NAME,
       SUBSTR(s.PROGRAM,INSTR(s.PROGRAM,'(')+1,4) PROCESS_NAME, 
       c.SID,
       c.SERIAL#, 
       c.STATE,
       c.TOTAL_MESSAGES_CAPTURED,
       c.TOTAL_MESSAGES_ENQUEUED 
  FROM V$STREAMS_CAPTURE c, V$SESSION s
  WHERE c.SID = s.SID AND
        c.SERIAL# = s.SERIAL#;
============
For ignoring transaction at capture , use the following steps on source site: 

execute dbms_capture_adm.stop_capture('CAPTURE_NAME'); 
execute dbms_capture_adm.set_parameter('CAPTURE_NAME','_ignore_transaction','TXN_ID'); 
execute dbms_capture_adm.start_capture('CAPTURE_NAME'); 


SELECT capture_name,((SYSDATE - CAPTURE_MESSAGE_CREATE_TIME)*86400) LATENCY_SECONDS, ((SYSDATE - CAPTURE_TIME)*86400) LAST_STATUS, 
TO_CHAR(CAPTURE_TIME, 'HH24:MI:SS MM/DD/YY') CAPTURE_TIME, TO_CHAR(CAPTURE_MESSAGE_CREATE_TIME, 'HH24:MI:SS MM/DD/YY') CREATE_TIME 
FROM V$STREAMS_CAPTURE 
/

select STREAMS_NAME,STREAMS_TYPE,CUMULATIVE_MESSAGE_COUNT,TOTAL_MESSAGE_COUNT,LAST_MESSAGE_TIME from V$STREAMS_TRANSACTION where streams_type='APPLY' and CUMULATIVE_MESSAGE_COUNT <> TOTAL_MESSAGE_COUNT ;

COLUMN CAPTURE_NAME HEADING 'Capture|Process|Name' FORMAT A15
COLUMN QUEUE_NAME HEADING 'Capture|Process|Queue' FORMAT A15
COLUMN STATUS HEADING 'Capture|Process|Status' FORMAT A15
SELECT CAPTURE_NAME, QUEUE_NAME,  STATUS
FROM DBA_CAPTURE;

COLUMN CAPTURE_NAME HEADING 'Capture|Name' FORMAT A15
COLUMN STATE HEADING 'State' FORMAT A27
COLUMN STATE_CHANGED HEADING 'State|Change Time'
COLUMN CREATE_MESSAGE HEADING 'Last Message|Create Time'
SELECT CAPTURE_NAME,
STATE,
TO_CHAR(STATE_CHANGED_TIME, 'HH24:MI:SS MM/DD/YY') STATE_CHANGED,
TO_CHAR(CAPTURE_MESSAGE_CREATE_TIME, 'HH24:MI:SS MM/DD/YY') CREATE_MESSAGE
FROM V$STREAMS_CAPTURE;


COLUMN APPLY_NAME HEADING 'Apply|Process|Name' FORMAT A15
COLUMN QUEUE_NAME HEADING 'Apply|Process|Queue' FORMAT A15
COLUMN STATUS HEADING 'Apply|Process|Status' FORMAT A15
SELECT APPLY_NAME,
QUEUE_NAME,
STATUS
FROM DBA_APPLY;

COLUMN REASON HEADING 'Reason for Alert' FORMAT A35
COLUMN SUGGESTED_ACTION HEADING 'Suggested Response' FORMAT A35
 
SELECT REASON, SUGGESTED_ACTION 
   FROM DBA_ALERT_HISTORY 
   WHERE MODULE_ID LIKE '%STREAMS%';
   
 select capture_name,error_message from dba_capture;
 select * from  V$BUFFERED_PUBLISHERS
 
 COLUMN CAPTURE_NAME HEADING 'Capture|Process|Name' FORMAT A10
COLUMN STATUS_CHANGE_TIME HEADING 'Abort Time'
COLUMN ERROR_NUMBER HEADING 'Error Number' FORMAT 99999999
COLUMN ERROR_MESSAGE HEADING 'Error Message' FORMAT A40

SELECT CAPTURE_NAME, STATUS_CHANGE_TIME, ERROR_NUMBER, ERROR_MESSAGE
  FROM DBA_CAPTURE WHERE STATUS='ABORTED';
====================

EXEC dbms_aqadm.STOP_QUEUE('EMCDU.ACTMESSAGE_Q');
EXEC dbms_aqadm.DROP_QUEUE('EMCDU.ACTMESSAGE_Q');
EXEC dbms_aqadm.STOP_QUEUE('EMCDU.INT$ACTEVENT_Q');
EXEC dbms_aqadm.DROP_QUEUE('EMCDU.INT$ACTEVENT_Q'); 
 
 
EXEC dbms_aqadm.STOP_QUEUE('EMCDU.PMNTMESSAGE_Q');
EXEC  dbms_aqadm.DROP_QUEUE('EMCDU.PMNTMESSAGE_Q');
EXEC  dbms_aqadm.STOP_QUEUE('EMCDU.INT$PAYMEVENT_Q');
EXEC  dbms_aqadm.DROP_QUEUE('EMCDU.INT$PAYMEVENT_Q');

========================
select * from V$STREAMS_TRANSACTION;  
  
col oldest_scn_num HEADING 'Oldest|SCN'
col apply_name HEADING 'Apply Name'
col apply_captured HEADING 'Captured or|User-Enqueued LCRs'
col process_name HEADING 'Process' for a5
col state HEADING 'STATE'
col total_messages_dequeued HEADING 'Total Messages|Dequeued'
col total_messages_spilled Heading 'Total Messages|Spilled'
col sga_used HEADING 'SGA Used'
col oldest_transaction_id HEADING 'Oldest|Transaction' for a30

SELECT ap.APPLY_NAME,
       DECODE(ap.APPLY_CAPTURED,
                'YES','Captured LCRS',
                'NO','User-Enqueued','UNKNOWN') APPLY_CAPTURED,
       SUBSTR(s.PROGRAM,INSTR(S.PROGRAM,'(')+1,4) PROCESS_NAME,
       r.STATE,
       r.TOTAL_MESSAGES_DEQUEUED,
       r.TOTAL_MESSAGES_SPILLED,
       r.SGA_USED, 
       oldest_scn_num,
       oldest_xidusn||'.'||oldest_xidslt||'.'||oldest_xidsqn 
             oldest_transaction_id
       FROM gV$STREAMS_APPLY_READER r, gV$SESSION s, DBA_APPLY ap
       WHERE r.SID = s.SID AND
             r.SERIAL# = s.SERIAL# AND
             r.APPLY_NAME = ap.APPLY_NAME;
			 
prompt  ++  APPLY PROGRESS ++
alter session set nls_date_format='DD/MM/YY HH24:MI:SS';
col source_database for a10
col oldest_message_number HEADING 'Oldest|Message|SCN' format 999999999999999
col apply_time HEADING 'Apply|Timestamp'
select * from dba_apply_progress;


col commitscn format 999999999999999
col DEP_COMMITSCN format 999999999999999
col DEP_TX_ID for a25
col TX_ID for a25
select SID, STATE, XIDUSN||'.'||XIDSLT||'.'||XIDSQN TX_ID, COMMITSCN,DEP_XIDUSN||'.'||DEP_XIDSLT||'.'||DEP_XIDSQN DEP_TX_ID, DEP_COMMITSCN,APPLY_TIME,APPLIED_MESSAGE_CREATE_TIME,ELAPSED_APPLY_TIME from v$streams_apply_server;


select s.username, s.sid, s.serial#,
t.xidusn, t.xidslot, t.xidsqn
from v$session s, v$transaction t
where s.taddr=t.addr and XIDUSN=&TXN; ===> Give XID from above query 

select * from v$logmnr_contents;  
  
select xid, xidusn, xidslt, xidsqn, mining_status from v$logmnr_transaction where mining_status = 'ACTIVE';  
  
select distinct xid from v$logmnr_transaction where mining_status = 'ACTIVE';  
  
select distinct sql_id from v$active_session_history where xid in (select distinct xid from v$logmnr_transaction where mining_status = 'ACTIVE');  
  
select sql_text from dba_hist_sqltext where sql_id in (select distinct sql_id from v$active_session_history where xid in (select distinct xid from v$logmnr_transaction where mining_status = 'ACTIVE'));  
========================

==========================
To list each required archive redo log file in a database, run the following query:

COLUMN CONSUMER_NAME HEADING 'Capture|Process|Name' FORMAT A15
COLUMN SOURCE_DATABASE HEADING 'Source|Database' FORMAT A10
COLUMN SEQUENCE# HEADING 'Sequence|Number' FORMAT 99999
COLUMN NAME HEADING 'Required|Archived Redo Log|File Name' FORMAT A40
 
SELECT r.CONSUMER_NAME,
       r.SOURCE_DATABASE,
       r.SEQUENCE#, 
       r.NAME 
  FROM DBA_REGISTERED_ARCHIVED_LOG r, DBA_CAPTURE c
  WHERE r.CONSUMER_NAME =  c.CAPTURE_NAME AND
        r.NEXT_SCN      >= c.REQUIRED_CHECKPOINT_SCN;
===========================
Displaying the Log Files That Will Never Be Needed by Any Capture Process

V$LOGMNR_LOGS
SELECT * FROM DBA_LOGMNR_PURGED_LOG;

SELECT name FROM v$archived_log WHERE next_change# < (SELECT first_scn FROM dba_capture);


select thread, seq+1 first_seq_missing , seq+(next_seq-seq-1) last_seq_missing, next_seq-seq-1 missing_count
 from   (select THREAD# thread, SEQUENCE# seq,
                lead (SEQUENCE#, 1, SEQUENCE#) over (partition by thread# order by sequence#) next_seq
          from dba_registered_archived_log, dba_capture
          where capture_name in (select capture_name from v$streams_capture)
          and consumer_name = capture_name)
 where  next_seq - seq > 1
 order  by 1,2;

 https://blogs.oracle.com/db/oracle-support-master-note-for-troubleshooting-streams-capture-waiting-for-redo-or-initializing-doc-id-3132791
=============================
http://www.oracledbasupport.co.uk/streams-replication-monitoring-oracle-streams-apply-processes-at-destination-server/
#!/bin/bash
## Monitoring Oracle Streams Apply Processes at Destination Server
export STREAMS_ADMIN_SCHEMA=STRMADMIN
export STREAMS_ADMIN_SCHEMA_PWD=STRMADMIN
export DEST_DB=streams1

echo "-------------------Menu---------------------------"
echo " **** This script was tested against RHEL/Oracle 10gR2, Please update script variables with right database values ***"
echo "To run option 16 you will need some plsql procedures in place, detailed at http://www.oracledbasupport.co.uk/streams-displaying-detailed-information-about-apply-errors/"
echo ""
flag=0
while [ $flag -ne 17 ]
do
echo "1.  Determining the Queue, Rule Sets, and Status for Each Apply Process"
echo "2.  Displaying General Information About Each Apply Process"
echo "3.  Listing the Parameter Settings for Each Apply Process"
echo "4.  Displaying Information About Apply Handlers"
echo "5.  Displaying Information About the Reader Server for Each Apply Process"
echo "6.  Monitoring Transactions and Messages Spilled by Each Apply Process"
echo "7.  Determining Capture to Dequeue Latency for a Message"
echo "8.  Displaying General Information About Each Coordinator Process"
echo "9.  Displaying Information About Transactions Received and Applied"
echo "10. Determining the Capture to Apply Latency for a Message for Each Apply Process"
echo "11. Displaying Information About the Apply Servers for Each Apply Process"
echo "12. Displaying Effective Apply Parallelism for an Apply Process"
echo "13. Viewing Rules that Specify a Destination Queue on Apply"
echo "14. Viewing Rules that Specify No Execution on Apply"
echo "15. Checking for Apply Errors"
echo "16. Displaying Detailed Information About Apply Errors"
echo "17. Exit"

echo "Enter the option:"

read flag

echo "*******************************************************"
if [ $flag -eq 1 ]
then
#### Display this general information about each apply process in a database, run the following query:
sqlplus -s ${STREAMS_ADMIN_SCHEMA}/${STREAMS_ADMIN_SCHEMA_PWD}@${DEST_DB} <<EOF
COLUMN APPLY_NAME HEADING 'Apply|Process|Name' FORMAT A15
COLUMN QUEUE_NAME HEADING 'Apply|Process|Queue' FORMAT A15
COLUMN RULE_SET_NAME HEADING 'Positive|Rule Set' FORMAT A15
COLUMN NEGATIVE_RULE_SET_NAME HEADING 'Negative|Rule Set' FORMAT A15
COLUMN STATUS HEADING 'Apply|Process|Status' FORMAT A15

SELECT APPLY_NAME,
       QUEUE_NAME,
       RULE_SET_NAME,
       NEGATIVE_RULE_SET_NAME,
       STATUS
  FROM DBA_APPLY;
exit
EOF
fi

if [ $flag -eq 2 ]
then
#### To display this general information about each apply process in a database, run the following query:
sqlplus -s ${STREAMS_ADMIN_SCHEMA}/${STREAMS_ADMIN_SCHEMA_PWD}@${DEST_DB} <<EOF
COLUMN APPLY_NAME HEADING 'Apply Process Name' FORMAT A20
COLUMN APPLY_CAPTURED HEADING 'Type of Messages Applied' FORMAT A25
COLUMN APPLY_USER HEADING 'Apply User' FORMAT A30

SELECT APPLY_NAME,
       DECODE(APPLY_CAPTURED,
              'YES', 'Captured',
              'NO',  'User-Enqueued') APPLY_CAPTURED,
       APPLY_USER
  FROM DBA_APPLY;
exit
EOF
fi

if [ $flag -eq 3 ]
then
####   The following query displays the current setting for each apply process parameter for each apply process in a database:
sqlplus -s ${STREAMS_ADMIN_SCHEMA}/${STREAMS_ADMIN_SCHEMA_PWD}@${DEST_DB} <<EOF
COLUMN APPLY_NAME HEADING 'Apply Process|Name' FORMAT A15
COLUMN PARAMETER HEADING 'Parameter' FORMAT A25
COLUMN VALUE HEADING 'Value' FORMAT A20
COLUMN SET_BY_USER HEADING 'Set by User?' FORMAT A15

SELECT APPLY_NAME,
       PARAMETER,
       VALUE,
       SET_BY_USER
  FROM DBA_APPLY_PARAMETERS;
exit
EOF
fi

if [ $flag -eq 4 ]
then
#### To display the error handler for each apply process that applies changes locally in a database, run the following query:
sqlplus -s ${STREAMS_ADMIN_SCHEMA}/${STREAMS_ADMIN_SCHEMA_PWD}@${DEST_DB} <<EOF
COLUMN OBJECT_OWNER HEADING 'Table|Owner' FORMAT A5
COLUMN OBJECT_NAME HEADING 'Table Name' FORMAT A10
COLUMN OPERATION_NAME HEADING 'Operation' FORMAT A10
COLUMN USER_PROCEDURE HEADING 'Handler Procedure' FORMAT A30
COLUMN APPLY_NAME HEADING 'Apply Process|Name' FORMAT A15

SELECT OBJECT_OWNER,
       OBJECT_NAME,
       OPERATION_NAME,
       USER_PROCEDURE,
       APPLY_NAME
  FROM DBA_APPLY_DML_HANDLERS
  WHERE ERROR_HANDLER = 'Y'
  ORDER BY OBJECT_OWNER, OBJECT_NAME;

-- To display each message handler in a database, run the following query:
COLUMN APPLY_NAME HEADING 'Apply Process Name' FORMAT A20;
COLUMN MESSAGE_HANDLER HEADING 'Message Handler' FORMAT A20;

SELECT APPLY_NAME, MESSAGE_HANDLER FROM DBA_APPLY  WHERE MESSAGE_HANDLER IS NOT NULL;

-- To display each precommit handler in a database, run the following query:
COLUMN APPLY_NAME HEADING 'Apply Process Name' FORMAT A20
COLUMN PRECOMMIT_HANDLER HEADING 'Precommit Handler' FORMAT A30
COLUMN APPLY_CAPTURED HEADING 'Type of|Messages|Applied' FORMAT A15

SELECT APPLY_NAME,
       PRECOMMIT_HANDLER,
       DECODE(APPLY_CAPTURED,
              'YES', 'Captured',
              'NO',  'User-Enqueued') APPLY_CAPTURED
  FROM DBA_APPLY
  WHERE PRECOMMIT_HANDLER IS NOT NULL;

exit
EOF
fi

if [ $flag -eq 5 ]
then
#### The information displayed by this query is valid only for an enabled apply process.
#### Run the following query to display this information for each apply process:
sqlplus -s ${STREAMS_ADMIN_SCHEMA}/${STREAMS_ADMIN_SCHEMA_PWD}@${DEST_DB} <<EOF
COLUMN APPLY_NAME HEADING 'Apply Process|Name' FORMAT A15
COLUMN APPLY_CAPTURED HEADING 'Dequeues Captured|Messages?' FORMAT A17
COLUMN PROCESS_NAME HEADING 'Process|Name' FORMAT A7
COLUMN STATE HEADING 'State' FORMAT A17
COLUMN TOTAL_MESSAGES_DEQUEUED HEADING 'Total Messages|Dequeued' FORMAT 9999999999999

SELECT r.APPLY_NAME,
       ap.APPLY_CAPTURED,
       SUBSTR(s.PROGRAM,INSTR(s.PROGRAM,'(')+1,4) PROCESS_NAME,
       r.STATE,
       r.TOTAL_MESSAGES_DEQUEUED
       FROM V$STREAMS_APPLY_READER r, V$SESSION s, DBA_APPLY ap
       WHERE r.SID = s.SID AND
             r.SERIAL# = s.SERIAL# AND
             r.APPLY_NAME = ap.APPLY_NAME;

exit
EOF
fi

if [ $flag -eq 6 ]
then
sqlplus -s ${STREAMS_ADMIN_SCHEMA}/${STREAMS_ADMIN_SCHEMA_PWD}@${DEST_DB} <<EOF
-- select "Display information for each apply process in a database" from dual;
COLUMN APPLY_NAME HEADING 'Apply Name' FORMAT A20
COLUMN 'Transaction ID' HEADING 'Transaction ID' FORMAT A15
COLUMN FIRST_SCN HEADING 'First SCN'   FORMAT 99999999999999
COLUMN MESSAGE_COUNT HEADING 'Message Count' FORMAT 99999999

SELECT APPLY_NAME,
       XIDUSN ||'.'||
       XIDSLT ||'.'||
       XIDSQN "Transaction ID",
       FIRST_SCN,
       MESSAGE_COUNT
  FROM DBA_APPLY_SPILL_TXN;

COLUMN APPLY_NAME HEADING 'Apply Name' FORMAT A15
COLUMN TOTAL_MESSAGES_SPILLED HEADING 'Total|Spilled Messages' FORMAT 99999999
COLUMN ELAPSED_SPILL_TIME HEADING 'Elapsed Time|Spilling Messages' FORMAT 99999999.99

SELECT APPLY_NAME,
       TOTAL_MESSAGES_SPILLED,
       (ELAPSED_SPILL_TIME/100) ELAPSED_SPILL_TIME
  FROM V$STREAMS_APPLY_READER;
exit
EOF
fi

if [ $flag -eq 7 ]
then
sqlplus -s ${STREAMS_ADMIN_SCHEMA}/${STREAMS_ADMIN_SCHEMA_PWD}@${DEST_DB} <<EOF
COLUMN APPLY_NAME HEADING 'Apply Process|Name' FORMAT A17
COLUMN LATENCY HEADING 'Latency|in|Seconds' FORMAT 999999
COLUMN CREATION HEADING 'Message Creation' FORMAT A17
COLUMN LAST_DEQUEUE HEADING 'Last Dequeue Time' FORMAT A20
COLUMN DEQUEUED_MESSAGE_NUMBER HEADING 'Dequeued|Message Number' FORMAT 99999999999999999

SELECT APPLY_NAME,
     (DEQUEUE_TIME-DEQUEUED_MESSAGE_CREATE_TIME)*86400 LATENCY,
     TO_CHAR(DEQUEUED_MESSAGE_CREATE_TIME,'HH24:MI:SS MM/DD/YY') CREATION,
     TO_CHAR(DEQUEUE_TIME,'HH24:MI:SS MM/DD/YY') LAST_DEQUEUE,
     DEQUEUED_MESSAGE_NUMBER
  FROM V$STREAMS_APPLY_READER;
exit
EOF
fi

if [ $flag -eq 8 ]
then
sqlplus -s ${STREAMS_ADMIN_SCHEMA}/${STREAMS_ADMIN_SCHEMA_PWD}@${DEST_DB} <<EOF
COLUMN APPLY_NAME HEADING 'Apply Process|Name' FORMAT A17
COLUMN PROCESS_NAME HEADING 'Coordinator|Process|Name' FORMAT A11
COLUMN SID HEADING 'Session|ID' FORMAT 9999
COLUMN SERIAL# HEADING 'Session|Serial|Number' FORMAT 9999
COLUMN STATE HEADING 'State' FORMAT A21

SELECT c.APPLY_NAME,
       SUBSTR(s.PROGRAM,INSTR(s.PROGRAM,'(')+1,4) PROCESS_NAME,
       c.SID,
       c.SERIAL#,
       c.STATE
       FROM V$STREAMS_APPLY_COORDINATOR c, V$SESSION s
       WHERE c.SID = s.SID AND
             c.SERIAL# = s.SERIAL#;
exit
EOF
fi

if [ $flag -eq 9 ]
then
sqlplus -s ${STREAMS_ADMIN_SCHEMA}/${STREAMS_ADMIN_SCHEMA_PWD}@${DEST_DB} <<EOF
COLUMN APPLY_NAME HEADING 'Apply Process Name' FORMAT A20
COLUMN TOTAL_RECEIVED HEADING 'Total|Trans|Received' FORMAT 99999999
COLUMN TOTAL_APPLIED HEADING 'Total|Trans|Applied' FORMAT 99999999
COLUMN TOTAL_ERRORS HEADING 'Total|Apply|Errors' FORMAT 9999
COLUMN BEING_APPLIED HEADING 'Total|Trans Being|Applied' FORMAT 99999999
COLUMN UNASSIGNED_COMPLETE_TXNS HEADING 'Total|Unnasigned|Trans' FORMAT 99999999
COLUMN TOTAL_IGNORED HEADING 'Total|Trans|Ignored' FORMAT 99999999

SELECT APPLY_NAME,
       TOTAL_RECEIVED,
       TOTAL_APPLIED,
       TOTAL_ERRORS,
       (TOTAL_ASSIGNED - (TOTAL_ROLLBACKS + TOTAL_APPLIED)) BEING_APPLIED,
       TOTAL_IGNORED
       FROM V$STREAMS_APPLY_COORDINATOR;
exit
EOF
fi

if [ $flag -eq 10 ]
then
sqlplus -s ${STREAMS_ADMIN_SCHEMA}/${STREAMS_ADMIN_SCHEMA_PWD}@${DEST_DB} <<EOF
COLUMN APPLY_NAME HEADING 'Apply Process|Name' FORMAT A17
COLUMN 'Latency in Seconds' FORMAT 999999
COLUMN 'Message Creation' FORMAT A17
COLUMN 'Apply Time' FORMAT A17
COLUMN HWM_MESSAGE_NUMBER HEADING 'Applied|Message|Number' FORMAT 99999999999999

SELECT APPLY_NAME,
     (HWM_TIME-HWM_MESSAGE_CREATE_TIME)*86400 "Latency in Seconds",
     TO_CHAR(HWM_MESSAGE_CREATE_TIME,'HH24:MI:SS MM/DD/YY')
        "Message Creation",
     TO_CHAR(HWM_TIME,'HH24:MI:SS MM/DD/YY') "Apply Time",
     HWM_MESSAGE_NUMBER
  FROM V$STREAMS_APPLY_COORDINATOR;

-- select "Following query will display capture to apply latency using DBA_APPLY_PROGRESS view for a captured LCR for each apply process" from dual;
COLUMN APPLY_NAME HEADING 'Apply Process|Name' FORMAT A17
COLUMN 'Latency in Seconds' FORMAT 999999
COLUMN 'Message Creation' FORMAT A17
COLUMN 'Apply Time' FORMAT A17
COLUMN APPLIED_MESSAGE_NUMBER HEADING 'Applied|Message|Number' FORMAT 9999999999999999

SELECT APPLY_NAME,
     (APPLY_TIME-APPLIED_MESSAGE_CREATE_TIME)*86400 "Latency in Seconds",
     TO_CHAR(APPLIED_MESSAGE_CREATE_TIME,'HH24:MI:SS MM/DD/YY')
        "Message Creation",
     TO_CHAR(APPLY_TIME,'HH24:MI:SS MM/DD/YY') "Apply Time",
     APPLIED_MESSAGE_NUMBER
  FROM DBA_APPLY_PROGRESS;

exit
EOF
fi

if [ $flag -eq 11 ]
then
#### Run the following query to display information about the apply servers for each apply process:
sqlplus -s ${STREAMS_ADMIN_SCHEMA}/${STREAMS_ADMIN_SCHEMA_PWD}@${DEST_DB} <<EOF
COLUMN APPLY_NAME HEADING 'Apply Process Name' FORMAT A22
COLUMN PROCESS_NAME HEADING 'Process Name' FORMAT A12
COLUMN STATE HEADING 'State' FORMAT A17
COLUMN TOTAL_ASSIGNED HEADING 'Total|Transactions|Assigned' FORMAT 99999999
COLUMN TOTAL_MESSAGES_APPLIED HEADING 'Total|Messages|Applied' FORMAT 99999999

SELECT r.APPLY_NAME,
       SUBSTR(s.PROGRAM,INSTR(S.PROGRAM,'(')+1,4) PROCESS_NAME,
       r.STATE,
       r.TOTAL_ASSIGNED,
       r.TOTAL_MESSAGES_APPLIED
  FROM V$STREAMS_APPLY_SERVER R, V$SESSION S
  WHERE r.SID = s.SID AND
        r.SERIAL# = s.SERIAL#
  ORDER BY r.APPLY_NAME, r.SERVER_ID;
exit
EOF
fi

if [ $flag -eq 12 ]
then
sqlplus -s ${STREAMS_ADMIN_SCHEMA}/${STREAMS_ADMIN_SCHEMA_PWD}@${DEST_DB} <<EOF
-- select "The following query displays the effective apply parallelism for an apply process named apply:" from dual;

SELECT COUNT(SERVER_ID) "Effective Parallelism"
  FROM V$STREAMS_APPLY_SERVER
  WHERE APPLY_NAME = 'APPLY' AND
        TOTAL_MESSAGES_APPLIED > 0;

-- select "You can display the total number of messages applied by each apply server by running the following query" from dual;
COLUMN SERVER_ID HEADING 'Apply Server ID' FORMAT 99
COLUMN TOTAL_MESSAGES_APPLIED HEADING 'Total Messages Applied' FORMAT 9999999999
SELECT SERVER_ID, TOTAL_MESSAGES_APPLIED
  FROM V$STREAMS_APPLY_SERVER
  WHERE APPLY_NAME = 'ACTEVENT_APPLY'
  ORDER BY SERVER_ID;
exit
EOF
fi

if [ $flag -eq 13 ]
then
sqlplus -s ${STREAMS_ADMIN_SCHEMA}/${STREAMS_ADMIN_SCHEMA_PWD}@${DEST_DB} <<EOF
-- select "To view destination queue settings for rules, run the following query:" from dual;
COLUMN RULE_OWNER HEADING 'Rule Owner' FORMAT A15
COLUMN RULE_NAME HEADING 'Rule Name' FORMAT A15
COLUMN DESTINATION_QUEUE_NAME HEADING 'Destination Queue' FORMAT A30
SELECT RULE_OWNER, RULE_NAME, DESTINATION_QUEUE_NAME
  FROM DBA_APPLY_ENQUEUE;
exit
EOF
fi

if [ $flag -eq 14 ]
then
sqlplus -s ${STREAMS_ADMIN_SCHEMA}/${STREAMS_ADMIN_SCHEMA_PWD}@${DEST_DB} <<EOF
-- select "To view each rule with NO for its execution directive, run the following query:" from dual;
COLUMN RULE_OWNER HEADING 'Rule Owner' FORMAT A20
COLUMN RULE_NAME HEADING 'Rule Name' FORMAT A20
SELECT RULE_OWNER, RULE_NAME
  FROM DBA_APPLY_EXECUTE
  WHERE EXECUTE_EVENT = 'NO';
exit
EOF
fi

## Checking for Apply Errors
if [ $flag -eq 15 ]
then
sqlplus -s ${STREAMS_ADMIN_SCHEMA}/${STREAMS_ADMIN_SCHEMA_PWD}@${DEST_DB} <<EOF
-- select "To check for apply errors, run the following query:" from dual;
COLUMN APPLY_NAME HEADING 'Apply|Process|Name' FORMAT A10
COLUMN SOURCE_DATABASE HEADING 'Source|Database' FORMAT A10
COLUMN LOCAL_TRANSACTION_ID HEADING 'Local|Transaction|ID' FORMAT A11
COLUMN ERROR_NUMBER HEADING 'Error Number' FORMAT 99999999
COLUMN ERROR_MESSAGE HEADING 'Error Message' FORMAT A20
COLUMN MESSAGE_COUNT HEADING 'Messages in|Error|Transaction' FORMAT 99999999

SELECT APPLY_NAME,
       SOURCE_DATABASE,
       LOCAL_TRANSACTION_ID,
       ERROR_NUMBER,
       ERROR_MESSAGE,
       MESSAGE_COUNT,
	   ERROR_CREATION_TIME
  FROM DBA_APPLY_ERROR where ERROR_CREATION_TIME >= sysdate-7;

exit
EOF
fi
done
echo "exit"
================================
COLUMN PROPAGATION_NAME HEADING 'Propagation' FORMAT A15
COLUMN SUBSCRIBER_ADDRESS HEADING 'Destination|Database' FORMAT A11
COLUMN CURRENT_ENQ_SEQ HEADING 'Current|Enqueued|Sequence' FORMAT 99999999
COLUMN LAST_BROWSED_SEQ HEADING 'Last|Browsed|Sequence' FORMAT 99999999
COLUMN LAST_DEQUEUED_SEQ HEADING 'Last|Dequeued|Sequence' FORMAT 99999999
COLUMN NUM_MSGS HEADING 'Number of|Messages|in Queue|(Current)' FORMAT 99999999
COLUMN TOTAL_SPILLED_MSG HEADING 'Number of|Spilled|Messages|(Cumulative)' 
  FORMAT 99999999

SELECT p.PROPAGATION_NAME,
       s.SUBSCRIBER_ADDRESS, 
       s.CURRENT_ENQ_SEQ,
       s.LAST_BROWSED_SEQ,     
       s.LAST_DEQUEUED_SEQ,
       s.NUM_MSGS,  
       s.TOTAL_SPILLED_MSG
FROM DBA_PROPAGATION p, V$BUFFERED_SUBSCRIBERS s, V$BUFFERED_QUEUES q 
WHERE q.QUEUE_ID = s.QUEUE_ID AND 
      p.SOURCE_QUEUE_OWNER = q.QUEUE_SCHEMA AND
      p.SOURCE_QUEUE_NAME = q.QUEUE_NAME AND 
      s.SUBSCRIBER_ADDRESS LIKE '%' || p.DESTINATION_DBLINK;
========================
Latency on your Streams environment is growing and you have observed that your apply servers are applying sequentially though apply parallelism has been set. When checking v$streams_apply_server, only one process is on EXECUTE TRANSACTION state, meanwhile others are waiting on 'WAIT DEPENDENCY'



Note that the processes on WAIT DEPENDENCY state are waiting for transaction id 0.0.0.


=========================
set linesize 300 pages 5000
col transaction_duration for a45

with transaction_details as
(select inst_id,
  ses_addr,sysdate - start_date as diff
from gv$transaction
)
select s.username,
to_char(trunc(t.diff))
||'days, '
||to_char(trunc(mod(t.diff*24,24)))
||' hours, '
||to_char(trunc(mod(t.diff*24*60,24)))
||' minutes, '
||to_char(trunc(mod(t.diff*24*60*60,60)))
||' seconds' as transaction_duration,
s.program,
s.terminal,
s.status,
s.sid,
s.serial# from gv$session s,
transaction_details t
where s.inst_id=t.inst_id and s.saddr=t.ses_addr order by t.diff desc;



USERNAME                       TRANSACTION_DURATION                          Program                     Terminal   STATUS      Session    SERIAL#
------------------------------ --------------------------------------------- --------------------------- ---------- -------- ---------- ----------
EMCDU                          3days, 2 hours, 14 minutes, 0 seconds         CMS_900_ALPHA_JBOSS                    INACTIVE ##########      35992
EMCDU                          2days, 9 hours, 11 minutes, 9 seconds         CMS_900_SIGMA_JBOSS                    INACTIVE ##########      48579
EMCDU                          0days, 5 hours, 11 minutes, 25 seconds        CMS_900_THETA_JBOSS                    INACTIVE ##########      53450
EMCDU                          0days, 3 hours, 22 minutes, 15 seconds        JBossEMCDU                  unknown    INACTIVE ##########      17025
BSCSADM                        0days, 2 hours, 1 minutes, 28 seconds         Toad.exe                    DV04CTXAS8 INACTIVE ##########      41155
                                                                                                         0

BSCSADM                        0days, 1 hours, 7 minutes, 51 seconds         Toad.exe                    DV04CTXAS1 INACTIVE ##########      11085
                                                                                                         79

SYSADM                         0days, 0 hours, 7 minutes, 22 seconds         oracle@bilprodb4 (J002)     UNKNOWN    ACTIVE   ##########      34310
BCH                            0days, 0 hours, 1 minutes, 7 seconds          bch@blprdap1 (TNS V1-V3)    pts/6      INACTIVE ##########      62221
BCH                            0days, 0 hours, 0 minutes, 44 seconds         bch@blprdap1 (TNS V1-V3)    pts/6      ACTIVE   ##########      58749
BCH                            0days, 0 hours, 0 minutes, 40 seconds         bch@blprdap3 (TNS V1-V3)    pts/2      INACTIVE ##########      61036
BCH                            0days, 0 hours, 0 minutes, 40 seconds         bch@blprdap3 (TNS V1-V3)    pts/2      INACTIVE ##########      20779
BCH                            0days, 0 hours, 0 minutes, 37 seconds         bch@blprdap3 (TNS V1-V3)    pts/2      INACTIVE ##########      62816
BCH                            0days, 0 hours, 0 minutes, 36 seconds         bch@blprdap3 (TNS V1-V3)    pts/2      INACTIVE ##########      44242
BCH                            0days, 0 hours, 0 minutes, 34 seconds         bch@blprdap1 (TNS V1-V3)    pts/6      INACTIVE ##########      45828
BCH                            0days, 0 hours, 0 minutes, 34 seconds         bch@blprdap1 (TNS V1-V3)    pts/6      INACTIVE ##########      55355
BCH                            0days, 0 hours, 0 minutes, 34 seconds         bch@blprdap1 (TNS V1-V3)    pts/6      INACTIVE ##########      34349
BCH                            0days, 0 hours, 0 minutes, 34 seconds         bch@blprdap1 (TNS V1-V3)    pts/6      INACTIVE ##########      47329
BCH                            0days, 0 hours, 0 minutes, 30 seconds         bch@blprdap1 (TNS V1-V3)    pts/6      INACTIVE ##########      10902
BCH                            0days, 0 hours, 0 minutes, 10 seconds         bch@blprdap1 (TNS V1-V3)    pts/6      INACTIVE ##########      51177
BCH                            0days, 0 hours, 9 minutes, 27 seconds         bch@blprdap4 (TNS V1-V3)    pts/1      INACTIVE ##########      58487
BCH                            0days, 0 hours, 9 minutes, 23 seconds         bch@blprdap4 (TNS V1-V3)    pts/1      INACTIVE ##########      28853
BCH                            0days, 0 hours, 9 minutes, 12 seconds         bch@blprdap3 (TNS V1-V3)    pts/2      INACTIVE ##########      13041
BCH                            0days, 0 hours, 7 minutes, 46 seconds         bch@blprdap4 (TNS V1-V3)    pts/1      ACTIVE   ##########      44019
BCH                            0days, 0 hours, 7 minutes, 46 seconds         bch@blprdap1 (TNS V1-V3)    pts/6      INACTIVE ##########      29452
BCH                            0days, 0 hours, 7 minutes, 40 seconds         bch@blprdap4 (TNS V1-V3)    pts/1      INACTIVE ##########      26013
BCH                            0days, 0 hours, 7 minutes, 36 seconds         bch@blprdap1 (TNS V1-V3)    pts/6      INACTIVE ##########      35829
BCH                            0days, 0 hours, 7 minutes, 31 seconds         bch@blprdap3 (TNS V1-V3)    pts/2      INACTIVE ##########      31827
BCH                            0days, 0 hours, 7 minutes, 22 seconds         bch@blprdap3 (TNS V1-V3)    pts/2      INACTIVE ##########      34595
BCH                            0days, 0 hours, 7 minutes, 19 seconds         bch@blprdap3 (TNS V1-V3)    pts/2      INACTIVE ##########      39391
BCH                            0days, 0 hours, 6 minutes, 46 seconds         bch@blprdap1 (TNS V1-V3)    pts/6      INACTIVE ##########      11953
BCH                            0days, 0 hours, 20 minutes, 7 seconds         bch@blprdap3 (TNS V1-V3)    pts/2      INACTIVE ##########      39612
BCH                            0days, 0 hours, 19 minutes, 57 seconds        bch@blprdap3 (TNS V1-V3)    pts/2      INACTIVE ##########      46768
BCH                            0days, 0 hours, 19 minutes, 52 seconds        bch@blprdap1 (TNS V1-V3)    pts/6      INACTIVE ##########      18790
BCH                            0days, 0 hours, 19 minutes, 41 seconds        bch@blprdap1 (TNS V1-V3)    pts/6      INACTIVE ##########      53152
BCH                            0days, 0 hours, 19 minutes, 38 seconds        bch@blprdap1 (TNS V1-V3)    pts/6      INACTIVE ##########      10600
BSCSADM                        0days, 0 hours, 19 minutes, 17 seconds        Toad.exe                    DV04CTXAS1 INACTIVE ##########      64429


col operation    heading 'operation'    format a20
col options      heading 'options'      format a20
col object_owner heading 'object|owner' format a10
col object_name  heading 'object|name'  format a10
col cost         heading 'cost'         format 99999999
 
select 
   p.operation, 
   p.options, 
   p.object_owner, 
   p.object_name, 
   p.cost
from 
   v$sql_plan p, 
   v$session s, 
   v$streams_apply_server a
where 
   a.apply_name = 'ACTEVENT_APPLY' 
--and 
  -- a.server_id = 2
and 
   s.sid = a.sid
and 
   p.hash_value = s.sql_hash_value;
   
select 
   t.sql_text
from 
   v$session s, 
   v$sqltext t, 
   v$streams_apply_server a
where 
   a.apply_name = 'ACTEVENT_APPLY'
and 
   a.server_id = 2
and 
   s.sid = a.sid
and 
   s.sql_address = t.address
and 
   s.sql_hash_value = t.hash_value
order by 
   piece;
======================================================================
High process CPU usage at the OS level

connect / as sysdba 
set pagesize 1000 

-- Capture 
define capture_name='<substitute relevant capture name>' 
select p.spid Spid, 'C00'||c.capture#||' '||upper(lp.role) "Capture Process ", c.capture_name "Capture Name", p.pga_used_mem "PGA Memory Used", p.pga_alloc_mem "PGA Memory Allocated", p.pga_max_mem "PGA Maximum Memory" 
from v$streams_capture c, v$logmnr_process lp, v$session s, v$process p 
where c.logminer_id = lp.session_id 
and lp.role in ('reader','preparer','builder') 
and lp.sid = s.sid 
and lp.serial# = s.serial# 
and s.paddr = p.addr 
and c.capture_name = '&capture_name' 
union 
select p.spid, 'C00'||c.capture#||' Coordinator', c.capture_name, p.pga_used_mem, p.pga_alloc_mem, p.pga_max_mem 
from v$streams_capture c, v$session s, v$process p 
where c.sid = s.sid 
and c.serial# = s.serial# 
and s.paddr = p.addr 
and c.capture_name = '&capture_name' 
order by 6,5;


connect / as sysdba 
set pagesize 1000 
-- Apply 
define apply_name='ACTEVENT_APPLY' 
select p.spid Spid, 'AP0'||sac.apply#||' Apply Coordinator' Process, sac.apply_name "Apply Name", p.pga_used_mem "PGA Memory Used", p.pga_alloc_mem "PGA Memory Allocated", p.pga_max_mem "PGA Maximum Memory" 
from v$streams_apply_coordinator sac, v$session s, v$process p 
where sac.sid = s.sid 
and sac.serial# = s.serial# 
and s.paddr = p.addr 
and sac.apply_name = '&apply_name' 
union 
select p.spid, 'AP0'||sas.apply#||' Server' Process, sas.apply_name "Apply Name", p.pga_used_mem "PGA Memory Used", p.pga_alloc_mem "PGA Memory Allocated", p.pga_max_mem "PGA Maximum Memory" 
from v$streams_apply_server sas, v$session s, v$process p 
where sas.sid = s.sid 
and sas.serial# = s.serial# 
and s.paddr = p.addr 
and sas.apply_name = '&apply_name' 
union 
select p.spid, 'AP0'||sar.apply#||' Reader' Process, sar.apply_name "Apply Name", p.pga_used_mem "PGA Memory Used", p.pga_alloc_mem "PGA Memory Allocated", p.pga_max_mem "PGA Maximum Memory" 
from v$streams_apply_reader sar, v$session s, v$process p 
where sar.sid = s.sid 
and sar.serial# = s.serial# 
and s.paddr = p.addr 
and sar.apply_name = '&apply_name' 
order by 6,5;

connect / as sysdba 
set pagesize 1000 
-- Propagation 
define prop_name='<substitute relevant propagation name>' 
select p.spid Spid, qs.process_name "Process ", pr.propagation_name "Propagation Name", pr.source_queue_owner ||'.'|| 
pr.source_queue_name ||'@'|| 
g.global_name "source queue", pr.destination_queue_owner ||'.'|| 
pr.destination_queue_name ||'@'|| 
pr.destination_dblink "Destination Queue", 
p.pga_used_mem "PGA Memory Used", p.pga_alloc_mem "PGA Memory Allocated", p.pga_max_mem "PGA Maximum Memory" 
from dba_queue_schedules qs, dba_propagation pr, v$session s, v$process p, global_name g 
where qs.session_id = s.sid||', '||s.serial# 
and qs.schema = pr.source_queue_owner 
and qs.qname = pr.source_queue_name 
and s.paddr = p.addr 
and qs.message_delivery_mode = 'BUFFERED' 
and pr.propagation_name = '&prop_name' 
order by 8,7; 


Platform	Command	Example
Linux	top	top -b -d2 -n30 -p spid1,spid2,spid3,etc > cpu.top 

30 snapshots taken 2 seconds apart for the Streams processes : spid1, spid2, spid3, etc. Output directed to file.
hp-ux	top	top -f cpu.top -s2 -d30 -n20 

record 30 snapshots each showing 20 processes taken 2 seconds apart. 
Second phase involves searching for Streams processes in output : 

egrep -i "CPU.*TTY|spid1|spid2|spid3|etc" cpu.top
AIX	top	Note: it is difficult to capture the output of topas to a file which is in a readable form. Therefore, the following achieves the same as above : 

sc=0 
while [ $sc -lt 30 ] 
do 
sc=`expr $sc + 1` 
sleep 2 
top 30 | tee -ia /tmp/cpu.out 
done 

egrep -i "CPU.*COMMAND|spid1|spid2|spid3|etc" /tmp/cap.out
Solaris	prstat	prstat -p spid1,spid2,spid3,etc 2 30 > cpu.top



===================================
DBA_LOG_GROUP_COLUMNS,


col current_txn format a15 wrap
col dependent_txn format a15 wrap
col source_database for a10
col oldest_message_number HEADING 'Oldest|Message|SCN' format 999999999999999
col commitscn format 999999999999999
col apply_time HEADING 'Apply|Timestamp'
col dep_commitscn format 9999999999999999

alter session set nls_date_format='DD/MM/YY HH24:MI:SS';

select APPLY_NAME, server_id SRVR,
xidusn||'.'||xidslt||'.'||xidsqn CURRENT_TXN,
commitscn,
dep_xidusn||'.'||dep_xidslt||'.'||dep_xidsqn DEPENDENT_TXN,
dep_commitscn,state,apply_time,APPLIED_MESSAGE_NUMBER,APPLIED_MESSAGE_CREATE_TIME
from  gv$streams_apply_server order by apply_name,server_id;

select * from dba_apply_progress;

select * from V$STREAMS_TRANSACTION where streams_type='APPLY'; 